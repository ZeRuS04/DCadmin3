/*==============================================================================
// File:    XThread.h
// Author:  Shvetsov Sergey <pp_serg@mail.ru>
// Version: 1.1 beta
// Begin:   12.10.12
// Read license.txt for more informations.
//============================================================================*/
//
//=============================================================================

#ifndef X_THREAD_H
#define X_THREAD_H

#include <QObject>
#include <QThread>

//======
class XThread: public QThread
{
  public:
    XThread(const QString &name);
	virtual ~XThread(void);
            // Получение флажка запущенного процесса.
	int 	SafeStartThread(unsigned short timeout=200);	// Запуск процесса с ожиданием и контролем.
	int		SafeStopThread(unsigned short timeout=200);		// Остановка процесса с ожиданием и контролем.
    const QString ThreadName(void)	{return thread_name;}	// Получение имени процесса.
//	int	  	XSelect(int nds, int cnt, time_ms timeout, fd_set * frd, fd_set * fwr=0L, fd_set * fex=0L);
	
  private:
	// Главная функция потока, реализующая работу потока. Поток завершается, когда эта функция 
	// заканчивает работу. Крайне рекомендуется ловить ВСЕ исключения в данной функции через try-catch(...). 
	// Возникновение неловимого никем исключения приведет к молчаливому падению программы без
	// возможности объяснить причину.
    virtual void run() = 0;
	
	// Присоединение к потоку. Данная функция вернет управление только когда поток завершит работу. 
	// Применяется при синхронизации потоков, если надо отследить завершение потока.
	void 	Join();
	
	// Уничтожение потока. Принудительно уничтожает поток извне. Данный способ завершения потока является 
	// крайне нерекомендуемым. Правильнее завершать поток логически, предусмотрев в функции Execute() 
	// условие для выхода, так самым обеспечив потоку нормальное завершение.
	void 	Kill();
	
	// Функция запуска потока. Ее нельзя совместить с конструктором класса, так как может случиться, 
	// что поток запустится до того, как объект будет полностью сформирован. А это может спокойно 
	// произойти, если вызвать pthread_create или CreateThread в /конструкторе. 
	// А вызов виртуальной функции в конструкторе, да еще и в конструкторе недосформированного объекта, 
	// в лучшем случае приведет к фатальной ошибке вызова чисто виртуальной функции, либо в худшем 
	// случае падению программы с нарушением защиты памяти. Запуск же потока после работы
	// конструктора избавляет от этих проблем. 
	void 	Start();	


    QString	thread_name;	// Имя потока для вывода диагностических сообщений.

	// Защита от случайного копирования объекта в C++
	XThread(const XThread &);
	void operator=(const XThread &);
};

#endif // X_THREAD_H
//=============================================================================
